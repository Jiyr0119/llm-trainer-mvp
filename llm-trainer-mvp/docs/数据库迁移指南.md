# 数据库迁移指南：从SQLite到PostgreSQL

## 概述

本文档记录了LLM Trainer项目从SQLite数据库迁移到PostgreSQL数据库的完整过程，包括环境准备、数据迁移步骤、遇到的问题及解决方案。

## 环境准备

### 1. 安装PostgreSQL

首先需要安装PostgreSQL数据库服务器。根据不同操作系统，安装方式有所不同：

- **macOS**：使用Homebrew安装
  ```bash
  brew install postgresql
  ```

- **Ubuntu/Debian**：使用apt安装
  ```bash
  sudo apt update
  sudo apt install postgresql postgresql-contrib
  ```

- **Windows**：从[PostgreSQL官网](https://www.postgresql.org/download/windows/)下载安装包

### 2. 创建数据库

安装完成后，创建用于LLM Trainer的数据库：

```bash
# 登录PostgreSQL
psql -U postgres

# 创建数据库
CREATE DATABASE llm_trainer;

# 退出
\q
```

### 3. 安装Python依赖

在项目根目录下安装必要的Python依赖：

```bash
pip install psycopg2-binary sqlalchemy sqlmodel
```

## 配置更新

### 1. 数据库连接配置

修改`.env`文件，添加PostgreSQL连接信息：

```
# SQLite配置（保留作为备份）
# DATABASE_URL=sqlite:///../data/database.db

# PostgreSQL配置
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/llm_trainer
```

### 2. 更新数据库连接代码

在`app/db.py`中，更新数据库连接代码，支持连接池和事务管理：

```python
from sqlmodel import SQLModel, create_engine, Session
from sqlalchemy.pool import QueuePool
import os
import logging

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 获取数据库URL
database_url = os.getenv("DATABASE_URL", "sqlite:///../data/database.db")

# 创建数据库引擎
if database_url.startswith("postgresql"):
    # PostgreSQL连接池配置
    engine = create_engine(
        database_url,
        echo=True,
        poolclass=QueuePool,
        pool_size=5,
        max_overflow=10,
        pool_timeout=30,
        pool_recycle=1800,
    )
else:
    # SQLite配置
    engine = create_engine(database_url, echo=True, connect_args={"check_same_thread": False})


def init_db():
    """初始化数据库，创建所有表"""
    SQLModel.metadata.create_all(engine)
    logger.info("数据库表结构初始化完成")


def get_session():
    """获取数据库会话"""
    with Session(engine) as session:
        try:
            yield session
        except Exception as e:
            session.rollback()
            logger.error(f"数据库会话错误: {e}")
            raise
```

## 数据迁移过程

### 1. 初始化PostgreSQL数据库表结构

首先需要在PostgreSQL中创建表结构。创建并运行`init_postgres_db.py`脚本：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
初始化PostgreSQL数据库表结构
"""

import os
import sys
import logging

# 添加项目根目录到Python路径
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# 设置环境变量
os.environ["DATABASE_URL"] = "postgresql://postgres:postgres@localhost:5432/llm_trainer"

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

from app.db import init_db

def main():
    """初始化PostgreSQL数据库表结构"""
    try:
        init_db()
        logger.info("PostgreSQL数据库表结构初始化成功")
    except Exception as e:
        logger.error(f"初始化PostgreSQL数据库表结构时出错: {e}")
        raise

if __name__ == "__main__":
    main()
```

### 2. 创建管理员用户

为了满足外键约束，需要创建一个管理员用户。创建并运行`create_admin_user.py`脚本：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
创建管理员用户脚本
"""

import os
import sys

# 添加项目根目录到Python路径
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app.db import get_session
from app.models import User
from sqlmodel import Session, select
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def create_admin_user():
    """创建管理员用户"""
    try:
        with get_session() as session:
            # 检查用户是否已存在
            statement = select(User).where(User.id == 1)
            existing_user = session.exec(statement).first()
            
            if existing_user:
                logger.info(f"ID为1的用户已存在: {existing_user.username}")
                return
            
            # 创建管理员用户
            user = User(
                id=1,
                username='admin',
                email='admin@example.com',
                hashed_password='$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW',  # 密码: password
                full_name='Admin User',
                role='admin',
                is_active=True
            )
            
            session.add(user)
            session.commit()
            logger.info("管理员用户创建成功")
    except Exception as e:
        logger.error(f"创建管理员用户时出错: {e}")
        raise

if __name__ == "__main__":
    create_admin_user()
```

### 3. 数据迁移

创建并运行`migrate_sqlite_to_postgres.py`脚本，将数据从SQLite迁移到PostgreSQL：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
从SQLite迁移数据到PostgreSQL

使用方法:
    python migrate_sqlite_to_postgres.py --sqlite-url sqlite:///../data/database.db --postgres-url postgresql://postgres:postgres@localhost:5432/llm_trainer
"""

import os
import sys
import json
import argparse
import logging
import pandas as pd
from datetime import datetime
import time
from sqlalchemy import create_engine, text
import app.models

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def backup_sqlite_data(sqlite_url, backup_dir):
    """从SQLite数据库备份所有表数据到JSON文件"""
    # 创建备份目录
    os.makedirs(backup_dir, exist_ok=True)
    
    # 连接SQLite数据库
    engine = create_engine(sqlite_url)
    
    # 获取所有表名
    with engine.connect() as conn:
        tables = conn.execute(text("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")).fetchall()
        table_names = [table[0] for table in tables]
    
    logger.info(f"发现表: {', '.join(table_names)}")
    
    # 备份每个表的数据
    for table_name in table_names:
        try:
            # 读取表数据
            df = pd.read_sql_table(table_name, engine)
            
            # 如果表为空，创建一个空的DataFrame
            if df.empty:
                logger.info(f"表 {table_name} 没有数据，创建空备份")
            
            # 保存为JSON文件
            backup_file = os.path.join(backup_dir, f"{table_name}.json")
            df.to_json(backup_file, orient='records')
            
            logger.info(f"表 {table_name} 已备份，记录数: {len(df)}")
        except Exception as e:
            logger.error(f"备份表 {table_name} 时出错: {e}")
            raise
    
    logger.info("SQLite数据备份完成")

def restore_to_postgres(backup_dir, postgres_url):
    """从备份文件恢复数据到PostgreSQL数据库"""
    from sqlmodel import SQLModel
    
    # 连接PostgreSQL数据库
    engine = create_engine(postgres_url)
    
    # 获取备份文件列表
    backup_files = [f for f in os.listdir(backup_dir) if f.endswith('.json')]
    
    # 按表依赖顺序排序（确保先导入被引用的表）
    priority_tables = ['dataset.json', 'user.json', 'role.json']
    backup_files = sorted(backup_files, key=lambda x: 
                         (priority_tables.index(x) if x in priority_tables else 999))
    
    # 从备份文件恢复数据
    for backup_file in backup_files:
        table_name = os.path.splitext(backup_file)[0]
        backup_path = os.path.join(backup_dir, backup_file)
        
        try:
            # 读取备份数据
            with open(backup_path, 'r') as f:
                data = json.load(f)
            
            # 如果没有数据，跳过
            if not data:
                logger.info(f"表 {table_name} 没有数据，跳过")
                continue
            
            # 处理时间戳字段
            for record in data:
                # 转换毫秒时间戳为datetime对象
                for field in ['created_at', 'updated_at', 'last_login', 'started_at', 'completed_at']:
                    if field in record and record[field] is not None:
                        try:
                            # 将毫秒时间戳转换为datetime对象
                            record[field] = pd.to_datetime(record[field], unit='ms')
                        except:
                            pass
            
            # 清空表，避免主键冲突
            with engine.connect() as conn:
                conn.execute(text(f"TRUNCATE TABLE {table_name} CASCADE"))
                conn.commit()
            
            # 使用pandas将数据导入到PostgreSQL
            df = pd.DataFrame(data)
            
            # 特殊处理trainingjob表
            if table_name == 'trainingjob':
                # 确保user_id字段有值
                if 'user_id' in df.columns:
                    df['user_id'] = df['user_id'].fillna(1)
                else:
                    df['user_id'] = 1
                
                # 使用SQL直接插入
                with engine.connect() as conn:
                    for _, row in df.iterrows():
                        # 获取列名和值
                        values = row.tolist()
                        columns = row.index.tolist()
                        
                        # 构建SQL语句
                        placeholders = ', '.join([':'+col for col in columns])
                        columns_str = ', '.join(columns)
                        sql = f"INSERT INTO {table_name} ({columns_str}) VALUES ({placeholders})"
                        
                        # 创建参数字典
                        params = {col: values[i] for i, col in enumerate(columns)}
                        
                        # 执行SQL
                        conn.execute(text(sql), params)
                    
                    conn.commit()
                
                logger.info(f"表 {table_name} 已恢复，记录数: {len(df)}")
            else:
                # 其他表使用pandas to_sql
                df.to_sql(table_name, engine, if_exists='append', index=False)
                logger.info(f"表 {table_name} 已恢复，记录数: {len(df)}")
                
        except Exception as e:
            logger.error(f"恢复表 {table_name} 时出错: {e}")
            raise
    
    logger.info("数据已成功恢复到PostgreSQL")

def verify_migration(sqlite_url, postgres_url, tables_to_check=None):
    """验证数据迁移是否成功"""
    # 连接数据库
    sqlite_engine = create_engine(sqlite_url)
    postgres_engine = create_engine(postgres_url)
    
    # 如果没有指定表，获取所有表
    if not tables_to_check:
        with sqlite_engine.connect() as conn:
            result = conn.execute(text("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'"))
            tables_to_check = [row[0] for row in result]
    
    logger.info("开始验证数据迁移")
    
    # 验证每个表的记录数
    for table in tables_to_check:
        try:
            # 获取SQLite表记录数
            with sqlite_engine.connect() as conn:
                sqlite_count = conn.execute(text(f"SELECT COUNT(*) FROM {table}")).scalar()
            
            # 获取PostgreSQL表记录数
            with postgres_engine.connect() as conn:
                postgres_count = conn.execute(text(f"SELECT COUNT(*) FROM {table}")).scalar()
            
            # 比较记录数
            if sqlite_count == postgres_count:
                logger.info(f"表 {table}: 验证成功 ({sqlite_count} 条记录)")
            else:
                logger.warning(f"表 {table}: 验证失败! SQLite: {sqlite_count} 条记录, PostgreSQL: {postgres_count} 条记录")
        except Exception as e:
            logger.error(f"验证表 {table} 时出错: {e}")
    
    logger.info("数据迁移验证完成")

def main():
    # 解析命令行参数
    parser = argparse.ArgumentParser(description='从SQLite迁移数据到PostgreSQL')
    parser.add_argument('--sqlite-url', required=True, help='SQLite数据库URL')
    parser.add_argument('--postgres-url', required=True, help='PostgreSQL数据库URL')
    args = parser.parse_args()
    
    print(f"SQLite URL: {args.sqlite_url}")
    print(f"PostgreSQL URL: {args.postgres_url}")
    
    # 创建备份目录
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_dir = f"./data/backup/migration_{timestamp}"
    
    # 备份SQLite数据
    backup_sqlite_data(args.sqlite_url, backup_dir)
    
    # 恢复数据到PostgreSQL
    restore_to_postgres(backup_dir, args.postgres_url)
    
    # 验证迁移
    verify_migration(args.sqlite_url, args.postgres_url)
    
    logger.info("数据库迁移完成!")

if __name__ == "__main__":
    main()
```

## 遇到的问题及解决方案

### 1. 表结构不存在问题

**问题**：运行测试脚本时出现`psycopg2.errors.UndefinedTable: relation "user" does not exist`错误。

**解决方案**：创建并运行`init_postgres_db.py`脚本，初始化PostgreSQL数据库表结构。

### 2. 模块导入问题

**问题**：运行迁移脚本时出现`No module named 'app.models.base'; 'app.models' is not a package`错误。

**解决方案**：修改导入语句，将`from app.models.base import SQLModel`改为`from sqlmodel import SQLModel`。

### 3. 数据类型不匹配问题

**问题**：恢复数据时出现`psycopg2.errors.DatatypeMismatch`错误，因为时间戳字段类型不匹配。

**解决方案**：在恢复数据前，将毫秒时间戳转换为datetime对象：

```python
# 转换毫秒时间戳为datetime对象
for field in ['created_at', 'updated_at', 'last_login', 'started_at', 'completed_at']:
    if field in record and record[field] is not None:
        try:
            record[field] = pd.to_datetime(record[field], unit='ms')
        except:
            pass
```

### 4. 外键约束问题

**问题**：恢复`trainingjob`表时出现`psycopg2.errors.ForeignKeyViolation`错误，因为缺少引用的用户记录。

**解决方案**：
1. 创建管理员用户，提供ID为1的用户记录
2. 确保按正确的顺序恢复表数据，先恢复被引用的表

### 5. SQL参数格式问题

**问题**：使用SQL直接插入数据时出现`List argument must consist only of tuples or dictionaries`错误。

**解决方案**：使用命名参数而不是位置参数：

```python
# 构建SQL语句
placeholders = ', '.join([':'+col for col in columns])
columns_str = ', '.join(columns)
sql = f"INSERT INTO {table_name} ({columns_str}) VALUES ({placeholders})"

# 创建参数字典
params = {col: values[i] for i, col in enumerate(columns)}

# 执行SQL
conn.execute(text(sql), params)
```

## 迁移后的验证

成功迁移后，所有表的记录数应与原SQLite数据库一致：

- `dataset`表：3条记录
- `modelartifact`表：0条记录
- `trainingjob`表：8条记录

## 后续步骤

1. 更新应用配置，将默认数据库连接改为PostgreSQL
2. 在生产环境中执行迁移
3. 保留SQLite作为备份或开发环境使用

## 参考资料

- [SQLAlchemy文档](https://docs.sqlalchemy.org/)
- [SQLModel文档](https://sqlmodel.tiangolo.com/)
- [PostgreSQL官方文档](https://www.postgresql.org/docs/)